# MySQL 서버
머리 역할을 담당하는 **MySQL 엔진**
손발 역할을 담당하는 **스토리지 엔진**

## MySQL 엔진
클라이언트 접속 및 쿼리 요청을 처리하는 커넥션 핸들러
SQL 파서 및 전처리기
쿼리의 최적화된 샐행을 위한 옵티마이저

## 스토리지 엔진
데이터를 디스크 스토리지에 저장하거나 읽어오는 부분을 담당
MySQL 엔진은 하나지만 스토리지 엔진은 여러개를 동시에 사용할 수 있다

# MySQL 스레딩 구조
MySQL 서버는 프로세스가 아닌 스레드 기반으로 작동.  
포그라운드(Foreground) 스레드와 백그라운드(Background) 스레드로 구분한다.

## 포그라운드 스레드
포그라운드 스레드는 최소 MySQL 서버에 접속된 클라리언트의 수만큼 존재.  
주로 클라이언트 사용자가 요청하는 쿼리 문장을 처리한다.  
작업을 마치고 커넥션을 종료하면 스레드는 스레드 캐시로 돌아간다.  
데이터를 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어온다.  
InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 디스크까지 기록하는 작업은 백그라운드 스레드가 처리한다.  

## 백그라운드 스레드
주요 역할은 **로그 스레드(Log thread)**와 **쓰기 스레드(Read thread)**이다.  
데이터를 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 읽기 스레드는 많이 설정할 필요가 없지만,  
쓰기 스레드는 많은 작업을 백그라운드로 처리하기 때문에 충분히 설정하는 것이 좋다.  

# 메모리 할당 및 사용 구조
> MySQL의 메모리 공간은 크게 **글로벌 메모리 영역**과 **로컬 메모리 영역**으로 구분한다.  

## 글로벌 메모리 영역
일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당.  
필요에 따라 N개의 메모리 공간을 할당받았다 하더라도 모든 스레드에 의해 공유됨.  

## 로컬 메모리 영역
세션 메모리 영역이라고도 표현한다.  
클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역이다.  
클라이언트와 MySQL 서버와의 커넥션을 세션이라고 하기 때문에 로컬 메모리 영역을 세션 메모리 영역이라고도 표현한다.  
로컬메모리는 각 스레드별로 독립적으로 할당되며 **절대 공유되지 않는다.**  

필요할 때만 공간이 할당되고 필요하지 않은 경우, 메모리 공간을 할당조차도 하지 않을 수도 있다.  
대표적으로 **소트 버퍼**나 **조인 버퍼**가 있다.  

# 플러그인 스토리지 엔진 모델
> 각 스토리지 엔진에게서 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸들러를 통해야 한다.  

데이터 읽기/쓰기 작업은 대부분 1건의 레코드 단위로 처리된다.  
MySQL 서버에서 MySQL 엔진은 사람 역할을 하고 각 스토리지 엔진은 자동차 역할을 하는데,  
MySQL 엔진이 스토리지 엔진을 조정하기 위해 핸들러라는 것을 사용한다.  

하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데,  
각 하위 작업이 MySQL 엔진 영역에서 처리되는지 아니면 스토리지 엔진 영역에서 처리되는지 구분할 줄 알아야 한다.  

# 컴포넌트
기존의 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처가 지원된다.  
MySQL의 서버의 플러그인은 아래와 같은 단점이있다.  
> 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음  
  서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 안 됨)  
  상호 의존 관계를 설정할 수 없어서 초기화가 어려움  

# 쿼리 실행 구조
## 쿼리 파서
> 토큰, MySQL이 인식할 수 있는 최소 단위의 어휘나 기호

쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만드는 작업을 수행.  
기본 문법 오류는 이 과정에서 발견된다.  

## 전처리기
파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다.  
객체 존재 여부와 객체의 접근 권한 등을 확인.  
실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰은 이 단계에서 걸러진다.  

### 스레드 풀
사용자의 요청을 처리하는 스레드 개수를 줄여서 많은 요청이 오더라도  
제한된 개수의 스레드 처리에만 집중할 수 있게 서버의 자원 소모를 줄이는 것이 목적이다.  

스레드 풀만 설치한다고 성능이 향상되는 것은 아니다.  
스케줄링 과정에서 CPU 시간을 제대로 확보하지 못하는 경우, 쿼리 처리가 더 느려질수도 있다.  

# innoDB 스토리지 엔진 아키텍처
MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며  
그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.  

## 프라이머리 키에 의한 클러스터링
> 클러스터링?  서로 유사한 속성을 갖는 데이터를 같은 군집으로 묶어주는 작업

InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장된다.  
프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 빨리 처리될 수 있다.  
결과적으로 쿼리의 실행계획에서 다른 보조 인덱스보다 프라이머리 키가 선택될 확률이 높다.  

### MVCC(Multi Version Concurrency Control)
> 주요 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있다

InnoDB는 Undo Log를 이용해 이 기능을 구현한다.  

UPDATE 문장이 실행되면 커밋 실행 여부와 관계없이 InnoDB의 버퍼 풀은 새로운 값으로 업데이트 된다.  
COMMIT이나 ROLLBACK 되지 않은 상태에서 다른 사용자가 작업 중인 레코드를 조회했을 때, 격리 수준에 따라 데이터를 반환하는 영역이 다르다.  
READ_COMMITTED나 그 이상의 격리 수준인 경우 Undo 영역의 데이터를 반환하고, READ_UNCOMMITTED의 경우 InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 반환한다.  
롤백을 실행하면 InnoDB는 Undo 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고, Undo 영역의 내용을 삭제한다.  

이처럼 격리 수준에 따라 서로 다른 데이터를 반환하면서 동시성 제어를 수행한다.  

## 자동 데드락 감지
InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 **그래프(Wait-for List)** 형태로 관리한다.  
데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착상태에 빠진 트랜잭션들을 찾고 그 중 하나를 강제종료한다.  
이때 어느 트랜잭션을 먼저 종료할 것인지 판단하는 기준은 Undo Log의 양이다.  
롤백을 해도 Undo 처리를 해야 할 내용이 적기 때문.  

## InnoDB 버퍼 풀
스토리지 엔진에서 가장 핵심적인 부분  
데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다.  
쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 한다.  

데이터를 변경하는 쿼리는 이곳저곳에 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시킨다.  
버퍼 풀이 변경된 데이터를 모아서 처리하면 랜덤한 디스크 작업의 횟수를 줄일 수 있다.  

## 버퍼 풀의 크기 설정
InnoDB 버퍼 풀은 전통적으로 버퍼 풀 전체를 관리하는 세마포어로 인해 내부 잠금 경합을 많이 유발해왔는데,  
이러한 경합을 줄이기 위해 버퍼 풀을 여러 개로 쪼개어 관리할수 있게 개선됐다.  
버퍼 풀이 여러 개의 작은 버퍼 풀로 쪼개지면서 개별 버퍼 풀 전체를 관리하는 세마포어 자체도 경합이 분산되는 효과를 낸다.  

## 버퍼 풀의 구조
버퍼 풀이라는 거대한 메모리 공간을 **페이지 크기**의 조각으로 쪼갠다.  
InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 **데이터 페이지를 읽어서 각 조각에 저장한다.**  

버퍼 풀의 **페이지 크기 조각**을 관리하기 위해,  
크게 **LRU(Least Recently Used) 리스트**와 **플러시(Flush) 리스트**, **프리(Free) 리스트** 3개의 자료 구조를 관리한다.  

프리 리스트는 비어 있는 페이지들의 목록이며, 새롭게 데이터 페이지를 읽어와야 하는 경우 사용된다.  
LRU는 LRU와 MRU(Most Recently Used) 리스트가 결합된 형태다.  
LRU 리스트의 목적은 디스크로부터 읽어온 페이지를 오랫동안 InnoDB 버퍼 풀의 메모리에 유지해서 디스크 읽기를 최소화 하는 것이다.  
플러시 리스트는 더티 페이지의


