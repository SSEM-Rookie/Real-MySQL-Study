# 4.1 MySQL 엔진 아키텍쳐

## MySQL란

MySQL 서버 = MySQL 엔진(1개) + 스토리지 엔진(여러개 가능)

- MySQL 엔진
- 스토리지 엔진

### MySQL 엔진 (두뇌)

- 커넥션 핸들러
    - 클라이언트로부터의 접속 및 쿼리 요청 -> 처리
    
- SQL 파서 + 전처리기
    - Query를 토큰으로 분리해 MySQL 이 인식할 수 있는 트리 형태의 구조로 만듬
    - 여기서 오류도 검사하는 듯(?)
    - 결국 DB서버가 이해할 수 있는 수준으로 파스 트리 함
    - 파스 트리할때 어떤 테이블 부터 읽을지, 어떤 인덱스를 볼지 선택
    - 불필요한 조건이면 단순화하거나 제거함
    - 조인의 경우는 어떤 순서로 읽을지도 파서 단계에서 정함
    
- 옵티마이저
    - 옵티마이저는 말 그대로 데이터를 기반으로 최적의 실행 계획을 수립해주는 것 
    
    - 규칙 기반 최적화
        - 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 Optimizer에 내장된 우선순위에 따라 실행 계획을 수립
        - 통계 정보를 참조하지 않기 때문에 같은 쿼리에 대해서 같은 실행 계획을 만든다.
        - 초기 버전의 오라클 DBMS에서 많이 사용했다.
        - 사용자의 데이터는 분포도가 매우 다양하기 때문에 현재로써는 많은 DBMS에서 사용하지 않는다. 
        
    - 비용 기반 최적화
        -  쿼리를 처리하기 위한 여러 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 통계 정보를 이용해서 각 실행 계획의 비용을 산출한다.
        - 산출된 정보를 이용해서 가장 적은 비용이 드는 실행 계획을 선택해서 쿼리를 실행한다.
        - 현재는 대부분의 RDBMS가 채택하고 있으며, MySQL 역시 마찬가지다.

### 스토리지 엔진

- 디스크에 데이터를 저장 수행

```sql
mysql> CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
```

### 핸들러 API

- 핸들러 요청 : MySQL에서 스토리지 엔진에 데이터를 변경하고 검색 등을 요청

## MySQL 스레딩 구조

- 포그라운드 스레드 (쿼리 문장 처리)
- 백그라운드 스레드 (인서트 병합, 로그 디스크 기록 등등..)

데이터 쓰기 작업은 지연되도 읽기 작업은 절대 지연될 수 없다.

## 메모리 할당 및 사용 구조

MySQL은 **글로벌 메모리**, **로컬 메모리**로 구별

- 글로벌 메모리 영역
    - 하나의 메모리 공간 할당
    - 글로벌 변수 처럼 스레드 수와 무관하고 **모든 스레드에 공유**된다고 생각
    - 테이블 캐시, InnoDB 버퍼 풀, InnoDB 어댑티브 해시 인덱스, InnoDB 리두 로그 버퍼
    
- 로컬 메모리 영역
    - **클라이언트 스레드 쿼리 처리 하는 영역** 
    - 정렬 버퍼, 조인 버퍼, 바이너리 로그 캐시, 네트워크 버퍼

## 플러그인 스토리지 엔진 모델
- 사용자 인증, 검색, 스토리지 엔진 등을 플러그인 형태로 개발 사용 가능
- 사용자가 직접 개발해서 플러그인 붙일 수 있음
- 데이터의 읽기와 쓰기만을 스토리엔진에서 처리

## 컴포넌트

MySQL 서버의 플러그인의 단점
- 플러그인끼리 통신할 수 없음
- 플러그인은 MySQL 서버의 벼수나 함수를 직접 호출하기 때문에 안전하지 않다.
- 플러그인은 상호 의존 관계를 설정할 수  없어서 초기화가 어려움

**플러그인의 단점을 컴포넌트가 보완하고 지원 함**


## 쿼리 실행 구조


### 쿼리 파서
- 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리하고 **파서 트리**형태 구조로 만들어내는 작업
- 기본 문법 오류는 여기서 발견! 오류를 전달

### 전처리기
- 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다

### 옵티마이저
- 사용자의 요청으로 들어온 쿼리 문장을 낮은 비용으로 가장 빠르게 처리할지를 결정하는 역할을 담당하며, DBMS의 두뇌에 해당한다

### 실행 엔진
- 실행 엔진은 만들어진 계획대로 핸들러(스토리지 엔진)에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다

### 핸들러
- 스토리지 엔진임 

## 복제
- 중요한 역할 나중에 16장에 다시 다룸

## 쿼리 캐시
- 빠른 응답을 필요로 하는 웹 기반 응용 프로그램에서 매우 중요한 역할을 담당
- 빠른 이유는 SQL의 실행 결과를 메모리에 캐시하고, 동일 SQL 쿼리가 실행되면 테이블을 읽지 않고 결과 반환
- MySQL8.0 부터 삭제됐다 (안녕)

## 스레드 풀
- 엔터프라이즈 에디션에서 제공되는 기능
- 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여 동시 처리되는 요청이 많더라도 CPU가 제한된 개수의 스레드만 처리에 집중할 수 있게해서 서버 자원 소모를 줄이는 것이 목적임
- 스레드 그룹의 모든 스레드가 일을 처리하고 있다면, 새로운 작업을 처리할지, 기존 작업을 처리할지 등을 판단

## 트랜잭션 지원 메타데이터
- 데이터베이스 서버에서 테이블 구조와 스토어드 프로그램들의 정보를 의미함 -> 데이터 딕셔너리

# InnoDB 스토리지 엔진 아키텍쳐
- InnoDB는 MySQL에서 사용하 ㄹ수 있는 엔진 중 유일한 레코드 기반 잠금을 제공, 동시성과 안정성면에서 좋음
- 하지만 단점으로 이원화 된 잠금 처리에 명령으로 접근이 어려움

## 프라이머리 키의 의한 클러스터링
- InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스러팅되어 저장
- 프라이머 키 값으 순으로 디스크 저장

## 외래 키 지원
- InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 SAM, MEMORY에서는 사용 불가
- InnoDB에서 FK는 부모, 자식 테이블 모두 해당 칼럼의 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요해 잠금이 여러 테이블로 전파 → 데드락 발생할 때가 많아짐
- 왜래 키가 복잡하면 `foreign_key_checks` 시스템 변수를 off로 설정해 체크 작업을 진행하면 훨씬 더 빠르게 진행

## MVCC(Multi Version Concurrency Control)
- 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능
- 잠금을 사용하지 않은 일관된 읽기를 제공에 목적
- InnoDB 같은 경우 Undo log 를 이용하여 이 기능을 구현한다.
- InnoDB에서는 데이터 수정이 이루어질 때, 새로운 값이 예전 값을 대체하고, 예전 값은 Undo log 영역에 복사
-  이 상태에서 COMMIT 명령을 실행하면 InnoDB는 더 이상의 변경 작업 없이 지금의 상태를 영구적인 데이터로 만듬
- 롤백을 실행하면 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고,  언두 영역의 내용을 삭제
- 백업 데이터가 항상 바로 삭제되는 것이 아닌, 언두 영역을 필요로 하는 트랜잭션이 더는 없을 때 비로소 삭제.


## 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)
- InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행

## 자동 데드락 감지
- InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리

## 자동화된 장애 복구
- InnoDB 스토리지 엔진은 매우 견고해서 데이터 파일이 손상되거나 MySQL 서버가 시작되지 못하는 경우는 거의 발생하지 않음. 혹여 디스크나 서버 하드웨어 이슈로 자동으로 복구하지 못한다면 복구하기 쉽지 않다.
- 이때는 MySQL 서버의 설정 파일에 innodb_force_recovery 시스템 변수를 설정해서 MySQL 서버를 재시작 해야된다. 이것도 안되면 리셋해야 함

## InnoDB 버퍼 풀
- InnoDB 스토리지 엔진에서 가장 핵심적인 부분
- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간

### 버퍼 풀의 크기 결정
- 버퍼의 풀을 동적으로 조절 가능
- 버퍼 풀의 크기를 적절히 작은 값으로 설정해서 조금씩 증가해보는게 최적임

### 버퍼 풀의 구조

### 버퍼 풀과 리두 로그

## 버퍼 풀 플러쉬

## Double Write Buffer

## 언두 로그

## 체인지 버퍼

## 어댑티브 해시 인덱스

# 로그 파일
