# 5장 트랜잭션과 잠금

트랜잭션 - 작업의 완전성 보장  
잠금 - 동시성을 제어하기 위한 기능  

# 트랜잭션 주의 사항
트랜잭션의 범위를 최소화 하라.  
- 트랜잭션이 필요한 순간(즉, DBMS에 저장 하거나 수정 하는 순간부터 끝나는 순간까지)만 트랜잭션을 유지하여야 커넥션의 불필요한 사용을 줄일 수 있다.  
- 외부 서버와 통신하는 작업은 가능하면 제거 하라  

# MY SQL 엔진의 잠금
MY SQL 엔진의 잠금 - 모든 스토리지 엔진에 영향    
스토리지 엔진의 잠금 - 스토리지 엔진 간 상호 영향 없음  

# 글로벌 락
전체 데이터베이스에 SELECT 문 제외 모든 DDL 이나 DML 대기  
주로 백업 용도로 사용, MY SQL 에서는 백업 락이 사용된다.  

# 백업 락
LOCK INSTANCE FOR BACKUP  
일관성 없는 스냅샷 작업을 방지 하면서 DML을 허용하는 인스턴스 수준 잠금  
여러 세션이 동시에 보유 가능  
파일이 생성, 이름 변경 또는 제거 방지  
리두 로그에 기록되지 않은 수정 작업도 차단  
사용자가 만든 임시 테이블에만 영향을 미치는 DDL 작업 허용  
백업 락 시작 시점의 스냅샷을 백업, 이후 리두 로그에 기록 된 변경 사항을 백업 파일에도 적용  

# 테이블 락
테이블 단위로 설정되는 잠금  
InnoDB 에서는 DML에서는 무시되고, DDL 작업시에 설정 된다.

# 네임드 락
임의의 문자열에 대해 잠금을 설정  
예시) 여러개의 배치 작업이 있을때, 해당 배치 작업들은 같은 네임드 락을 공유한다.  
이때, 임의의 배치 작업이 네임드 락을 사용 한다면, 다른 배치 작업들은 해당 네임드 락을 얻지 못하여, 대기 상태가 된다. 이후 임의의 배치 작업이 완료 된 후 네임드 락을 반환하면, 다른 배치 작업이 네임드 락을 얻고 실행 된다.  
MY SQL에서는 네임드 락을 중첩 사용 가능하고, 현재 세션에서 획득한 네임드 락을 한번에 모두 해제 하는 기능도 추가되었다.

# 메타데이터 락
데이터베이스 객체의 이름이나 구조를 변경하는 경우에 자동으로 획득하는 잠금.  
하나의 RENAME 명령문에 두개의 RENAME 작업을 한번에 실행하면 NOT FOUND 발생 시키지 않음, 2개로 나눠서 실행하면 NOT FOUND 발생 가능성 생김

# InnoDB 스토리지 엔진 잠금

# 레코드 락
레코드 자체만을 잠그는 것  
InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠금

# 갭 락
레코드 자체가 아니라 레코드와 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다.  
레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어.

# 넥스트 키 락
레코드 락 + 갭 락  
바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어 내도록 보장하는 것이 주 목적.

# 자동 증가 락
AUTO INCREMENT 가 적용된 칼럼에 여러 INSERT가 실행되는 경우, 순서대로 증가 해야 하기 때문에 사용되는 테이블 수준의 잠금  
AUTO INCREMENT 의 값을 가져오는 순간에 순간적으로 잠금 되었다가 해제 된다.  
MODE = 1 여러개의 자동 증가 값을 한번에 가져와 사용한다. 연속되지 않고 누락될 수 있다.  
MODE = 2 유니크한 값이 생성되는것만 보장.  


# 인덱스와 잠금
InnoDB 에서는 검색한 인덱스의 레코드를 모두 락을 건다.  
인덱스가 있는 컬럼 A와 인덱스가 없는 컬럼 B를 AND로 검색 하게 되면, 먼저 컬럼 A를 인덱스로 검색 한 후 컬럼 B를 전체 검색하게 된다. 이때, 컬럼 A의 인덱스는 모두 잠금 상태가 된다.  
만약 인덱스가 없으면 테이블 풀 스캔 되기 때문에 테이블의 모든 데이터가 잠길 것이다.  

# 레코드 수준의 잠금 확인 및 해제
프로세스 리스트를 보고, 해당 프로세스를 킬 한다.  

# MY SQL의 격리 수준
||DIRTY READ|NON_REPEATABLE READ|PHANTOM READ|  
|------|---|---|---|  
|READ UNCOMMITTED|발생|발생|발생|  
|READ COMMITTED|없음|발생|발생|  
|REPEATABLE READ|없음|없음|발생(InnoDB는 없음)|  
|SERIALIZABLE|없음|없음|설명|  

- READ UNCOMMITTED : 커밋 되기 전의 데이터들도 보여짐(롤백 되기 전에 SELECT 하면 해당 데이터가 보이기 때문에 사라진 데이터가 보여서 DIRTY READ라 한다.)  

- READ COMMITTED : 커밋 되기 전의 데이터는 보여지지 않음, NON_REPEATABLE READ 가 발생함  

- NON_REPEATABLE READ : 하나의 트랜잭션 내에서는 같은 쿼리문은 항상 같은 결과를 반환 해야 한다는 원칙. 트랜잭션 A가 TEST 테이블에서 SELECT문을 실행 하고, 트랜잭션이 종료 되기 전에 다시 똑같은 SELECT문을 실행 했을때, 다른 사용자가 커밋한 내역이 있으면 다른 결과가 반환 되는 현상.  

- REPEATABLE READ : 트랜잭션이 시작 될 때 스냅샷을 저장 해 두고, SELECT 실행 시 해당 스냅샷에서 데이터를 읽어옴, NON_REPEATABLE READ가 발생하지 않음  
InnoDB 에서는 레코드를 언두 공간에 백업 해두고 실제 값을 변경, 언두 영역을 이용해 동일한 결과를 보장한다.  
언두 영역에서는 가장 오래된 트랜잭션의 번호 이후의 변화를 기록 해 둔다. 따라서 장시간 트랜잭션이 유지되면 언두 영역은 무한정 커지며 성능 장애를 초래할 수도 있다.  

- PHANTOM READ : 다른 트랜잭션에서 삽입이나 삭제 할 경우, 처음 조회 시에는 없던 데이터가 새로 생겨나거나 없어지는 경우  
InnoDB에서 REPEATABLE READ 격리 수준은 Next-Key Locking이라는 기법을 사용하여 Phantom Reads를 방지합니다. Next-Key Locking은 인덱스 레코드와 해당 레코드의 갭(gap)에 락을 거는 방법으로, 쿼리에 의해 접근되는 범위 내에 새로운 데이터가 삽입되는 것을 방지합니다. 이로 인해, 한 트랜잭션이 실행되는 동안 다른 트랜잭션이 해당 범위에 데이터를 삽입할 수 없으므로, Phantom Reads가 발생하지 않습니다.

- SERIALIZABLE : 읽기 작업만 하여도 공유 읽기 잠금을 얻기 때문에, 읽기 작업 중인 레코드를 수정할 수 없다.  
만약 배타적 잠금을 설정 할 경우, 해당 트랜잭션이 끝나기 전에는 읽기 작업도 대기 하여야 한다.
