# 05. 트랜잭션과 잠금
> **잠금**(**Lock**)과 **트랜잭션**, **트랜잭션의 격리 수준**(Isolation level)에 대해 알아본다!

**트랜잭션**은 작업의 완전성과 데이터 정합성을 보장한다.
**잠금**은 동시성을 제어하기 위한 기능으로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다.  
**격리 수준**은 하나 또는 여러 트랜잭션 내에서 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨을 의미한다.  

# 트랜잭션
**트랜잭션**은 작업의 완전성과 데이터 정합성을 보장한다.  
트랜잭션의 범위는 최소화하는 것이 좋다. 데이터베이스 커넥션은 개수가 제한적이어서 각 프로그램이 커넥션을 소유하는 시간이 길어지면 커넥션을 가져가기 위해 대기해야 하는 상황이 발생할 수 있다.  

# 잠금
**잠금**은 동시성을 제어하기 위한 기능으로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다.  
MySQL에서 사용되는 잠금은 크게 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눌 수 있다.  
MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않는다.

## MySQL 엔진의 잠금
1. 글로벌 락
2. 테이블 락
3. 네임드 락
4. 메타데이터 락

## InnoDB 스토리지 엔진 잠금
InooDB 스토리지 엔진은 레코드 기반의 잠금 방식을 제공하여 뛰어난 동시성 처리가 가능하다.  

### 레코드 락(Record Lock)
레코드 자체만을 잠그는 것이다.  
InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다.  
인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.  
보조 인덱스를 이용한 변경 작업은 **Next Key Lock** 또는 **Gap Lock**을 사용하지만 PK 또는 Unique Index에 의한 변경작업에서는 **Gap Lock**을 사용하지 않고 레코드 자체에 대해서만 락을 건다.

> 클러스터 인덱스?  
> 일반적으로 PK를 의미한다!  
> 클러스터 인덱스는 인덱스 테이블을 사용하지 않고 인덱스 키 값의 순서대로 정렬되어 물리적으로 저장된다.  
> 테이블 당 하나만 존재할 수 있다.  
> 범위 검색에 유리하고 데이터 접근 효율성이 뛰어나지만 삽입, 삭제, 갱신의 성능 저하 가능성이 존재한다.   

### 갭 락(Gap Lock)
레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다.  
레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어하는 역할이다.  

### 넥스트 키 락(Next Key Lock)
MySQL 서버에서는 REPEATABLE READ 격리 수준을 사용해야 한다.  
InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다.  
넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생하므로 사용을 줄이는 것이 좋다.  

## 인덱스와 잠금
인덱스를 제대로 설정하지 않으면 1건의 업데이트를 위해 여러개의 레코드에 락을 걸어야 한다.  
만일 인덱스가 하나도 없다면 테이블을 풀 스캔하면서 UPDATE 작업을 하는데, 이 과정에서 테이블에 있는 모든 레코드를 잠그게 된다.  
이것이 InnoDB에서 인덱스 설계가 중요한 이유이다.  

# 격리 수준
여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수있게 허용할지 말지를 결정하는 것이다.  
4개의 격리 수준에서 순서대로 뒤로 갈수록 각 트랜잭션 간의 데이터 격리 정도가 높아지며, 동시 처리 성능도 떨어지는 것이 일반적이다.  

## 네 가지 격리 수준
![image](https://github.com/SSEM-Rookie/Real-MySQL-Study/assets/55777781/299d741f-6b8d-4879-96a7-ad408e623ae5)

## READ UNCOMMITTED
각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관없이 다른 트랜잭션에서 보인다.  
어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상을  **더티 리드**(Dirty Read)라고 한다.  

## READ COMMITTED
COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다.  
COMMIT을 수행하기 전에 다른 트랜잭션에서 SELECT 하면 Undo 영역에 백업된 레코드에서 데이터를 가져온다.  
다만, COMMIT을 수행하면 다른 트랜잭션에서 SELECT 할 때, 변경된 데이터가 조회된다.  
이는 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 한다는 REPEATABLE READ 정합성에 어긋나는 것이다.

## REPEATABLE READ
Repeatable Read 격리 수준에서는 한 트랜잭션 내에서 동일한 쿼리를 여러 번 실행하더라도 처음 읽은 데이터와 동일한 결과를 보장한다.  
이는 MVCC(Multi-Version Concurrency Control)를 사용하여 각 트랜잭션에 대해 데이터의 특정 버전을 유지함으로써 가능해진다.  
MVCC를 보장하기 위해 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 Undo 영역의 데이터는 삭제할 수가 없다.  
트랜잭션 안에서 실행되는 모든 SELECT는 트랜잭션 번호가 자신의 트랜잭션 번호보다 작은 트랜잭션 번호에서 변경한 것만 보게 된다.  

한 트랜잭션 내에서 동일한 쿼리를 두 번 이상 실행했을 때, 첫 번째 쿼리와 두 번째 쿼리의 결과가 다른 행의 집합으로 나타나는 현상을 **PHANTOM READ**라고 한다.  
Repeatable Read 격리 수준에서는 한 트랜잭션이 읽은 데이터의 일관성을 유지하지만, 새로 삽입되는 레코드에 대해서는 이러한 일관성을 보장하지 않는다.  
예를 들어, 한 트랜잭션 내에서 특정 조건을 만족하는 레코드를 조회하는 SELECT 쿼리를 실행한 후, 다른 트랜잭션이 동일한 조건을 만족하는 새로운 레코드를 삽입하고 커밋할 경우, 원래의 트랜잭션에서 동일한 SELECT 쿼리를 다시 실행하면 새로 삽입된 레코드가 결과에 포함되어 처음의 쿼리 결과와 다른 결과가 나타난다.  
이를 방지하기 위해서는 SELECT하는 레코드에 쓰기 잠금을 걸거나 SERIALIZABLE로 격리 수준을 변경해야 한다.  

InnoDB 스토리지 엔진은 Repeatable Read 격리 수준에서 Next-Key Locking을 사용하여 Phantom Read를 방지한다.  
이것은 범위 쿼리에 대해 쿼리 범위 내의 모든 레코드뿐만 아니라 해당 범위에 속할 수 있는 "갭(gap)"에도 잠금을 적용함으로써 새로운 레코드의 삽입을 방지한다.  

> SERIALIZABLE 격리수준에서 Phantom Read 현상이 방지되는 이유는?  
> 이 격리 수준이 데이터베이스 트랜잭션을 마치 순차적으로 실행된 것처럼 동작하게 만들기 때문이다.  

## SERIALIZABLE
### 특징
순차적 실행 보장  
- SERIALIZABLE 격리 수준에서는 모든 트랜잭션이 마치 순차적으로 실행되는 것처럼 동작한다.  
- 이는 동시에 실행되는 트랜잭션 간의 상호 작용이 발생하지 않도록 함으로써 데이터의 일관성을 보장한다.

범위 잠금(Range  Locks)  
- 이 격리 수준에서는 쿼리가 영향을 미치는 데이터 레코드뿐만 아니라 해당 쿼리의 범위 내에 포함될 수 있는 모든 레코드(실제 존재하는 레코드와 잠재적으로 삽입될 수 있는 레코드 포함)에 대해 잠금을 적용한다.  
- 이러한 범위 잠금은 새로운 레코드가 쿼리 결과 범위에 삽입되는 것을 방지하여 Phantom Read를 막는다.  

직렬화 가능 충돌  
- SERIALIZABLE 격리 수준에서는 트랜잭션이 데이터에 접근하려 할 때 충돌이 발생할 수 있으며, 이러한 충돌은 종종 롤백이나 재시도를 통해 해결해야 한다.
- 이는 트랜잭션 간의 엄격한 순차 실행을 보장하기 위한 조치이다.

### SERIALIZABLE는 특정 트랜잭션이 끝나야지만 다음 트랜잭션이 실행될 수 있는가?  
SERIALIZABLE 격리 수준에서 모든 트랜잭션이 마치 순차적으로 실행되는 것처럼 보이게 하는 것은 맞지만,  
이것이 반드시 특정 트랜잭션이 완전히 끝나야만 다음 트랜잭션이 시작될 수 있다는 의미는 아니다.  
SERIALIZABLE 격리 수준의 목적은 동시에 실행되는 트랜잭션들 사이에서 발생할 수 있는 데이터 불일치를 방지하여,  
결과적으로 모든 트랜잭션이 순차적으로 실행된 것과 같은 결과를 보장하는 것이다.  
