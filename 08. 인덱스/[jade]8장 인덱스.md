# 인덱스

# 랜덤 I/O 와 순차 I/O
순차 I/O : 저장장치에서 연속적으로 읽거나 쓰는 방식
랜덤 I/O : 무작위 위치에서 읽거나 쓰는 방식

HDD : 핀이 이동해야 하기 때문에 랜덤I/O가 불리
SSD : 랜덤I/O에서 성능이 더 좋음

DB에서 랜덤 I/O를 줄인다는 것은 필요한 데이터만 읽도록 쿼리를 개선한다는 것을 의미한다.

참고
- 인덱스 레인지 스캔은 랜덤 I/O를, 풀 테이블 스캔은 순차 I/O를 사용한다. 때문에, 큰 테이블의 데이터를 대부분 읽는 작업에서는 순차 I/O를 사용하기 위해 인덱스를 사용하지 않는 경우도 있다.

# 인덱스란?
자료를 빠르게 찾기 위해 데이터를 주어진 순서로 미리 정렬해서 보관 해 둔것
SORTEDLIST 처럼 항상 정렬된 상태로 유지된다.
저장 성능을 희생하고 읽기 속도를 높이는 기능

- HASH 인덱스 
칼럼의 값으로 해시값을 계산해서 인덱싱, 값을 변형해서 인덱싱 하므로 부분 검색, 범위 검색에서 사용 불가

# B-TREE 인덱스
BALANCED INDEX
칼럼의 값을 변경하지 않고 원래의 값을 이용해 인덱싱

1. 구조 및 특성

트리구조의 최상위에 하나의 루트 노드가 존재하고 그 하위에 자식 노드가 붙어있는 형태.
최 하위 노드를 리프 노드, 중간 노드를 브랜치 노드라고 한다.
리프 노드는 실제 데이터 레코드의 주솟값을 가지고 있다.

루트 노드는 자식 노드 주소를 가지고 있고, 브랜치 노드도 자식 노드 주소를 가지고 있다. 리프 노드는 실제 데이터의 주소값을 가지고 있다.

2. 추가 및 삭제

- 추가 : 저장될 키 값을 이용해 위치를 검색, 이후 리프 노드에 정보를 저장.
리프 노드가 꽉 차면 리프 노드를 분리 해야 하는데, 이때 상위 노드까지 수정 해야 해서 쓰기 작업에 비용이 많이 든다.
InnoDB 에서는 쓰기 작업을 지연시킬 수 있다.

- 삭제 : 리프 노드에서 삭제 마킹만 한다. i/o 작업

- 키 값 변경 : 기존 키 값 삭제 후 새로운 키 값 추가 하는 형태

- 검색 : 루트 노드부터 리프 노드까지 트리 탐색, 일치 혹은 앞부분 일치에서 사용 가능, 키값이 변형된 경우 인덱스 사용 불가능

3. B-TREE 인덱스 사용에 영향을 미치는 요소

컬럼의 크기, 레코드의 건수, 유니크한 인덱스 키 값의 갯수 등

- 인덱스 키 값의 크기
인덱스도 페이지 단위로 관리 되며, 루트, 브랜치, 리프 노드를 구분한 기준이 페이지 단위이다.
INNO DB 에서 페이지는 4 ~ 64kb 사이로 설정 가능, 기본 16KB
인덱스 키 값의 크기가 커지면, 하나의 페이지에 담을 수 있는 정보가 적어진다 = 자식 노드를 저장 할 수 있는 갯수가 줄어든다.
자식 노드의 저장 갯수가 줄어든다 = 같은 양의 데이터를 조회 할 때 디스크에서 읽어야 할 페이지가 많아 진다 = 느려진다.

- 선택도(SELECTIVITY) 혹은 기수성(CARDINALITY)
인덱스의 키 값 중에서 유니크한 값의 갯수.
유니크한 값이 많을수록 즉, 선택도가 높을 수록 중복 데이터가 적기 때문에 빠르게 처리 된다.
선택도가 낮더라도 그룹핑이나 정렬을 위해서 만드는게 좋은 경우도 있다. 꼭 검색 성능만이 인덱스의 생성 이유가 아니다.

- 레코드의 건수
일반적인 DBMS의 옵티마이저 에서는 읽어야 하는 레코드의 건수가 전체 데이터의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블 풀 스캔 하는것이 비용면에서 효율적이다. 이때 강제로 인덱스를 사용하도록 힌트를 주어도 옵티마이저는 힌트를 무시 할 것이다.

4. B-TREE 인덱스를 통한 데이터 읽기

- 인덱스 레인지 스캔
검색해야 할 인덱스의 범위가 결정 됐을때 사용, 리프 노드의 레코드만 순서대로 읽으면 된다. 이때, 리프 노드의 순서대로 디스크에서 실제 값을 가져 오는데 레코드 한건 마다 랜덤 i/o가 발생한다. 그래서 인덱스를 통해 데이터를 읽는 방법은 비용이 많이 든다. 인덱스의 순서대로 데이터를 가져오기 때문에 항상 정렬된 상태로 값이 반환된다.

- 커버링 인덱스
인덱스 안에 모든 정보가 다 담겨 있어서 디스크 i/o 작업이 발생하지 않아 처리 속도가 빠르고 비용이 줄어드는 인덱스.

- 인덱스 풀 스캔
인덱스를 사용하지만 인덱스 레인지 스캔과는 달리 인덱스의 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스캔이라 한다.
조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닐 경우 사용된다. (a,b,c의 복합 인덱스에서 b를 조건으로 사용)
인덱스에 포함된 컬럼만 검색하기 때문에 테이블 풀 스캔보다 비용이 적게 발생한다.

- 루스 인덱스 스캔
인덱스 레인지 스캔과 비슷하지만, 중간에 필요치 않은 값은 무시 하고 다음으로 넘어가는 형태.
일반적으로 group by 또는 max(), min()함수에 대해 최적화를 하는 경우에 사용된다.
복합 인덱스에서 하위 컬럼에서 조건절을 만족 했다면, 상위 컬럼들이 같은 하위 컬럼은 무시 하는 형태.
이는 인덱스가 정렬되어 있기 때문에 가능.
즉, 인덱스의 2번째 컬럼에 max를 걸었다면, 인덱스에서는 2번째 컬럼이 정렬되어 있으므로 바로 max값을 찾고 1번째 컬럼 값이 같은 경우는 무시가 가능 한 것.(group_id, max(score) 라고 한다면, 그룹 아이디로 인덱스를 타고 들어와 맥스 값(맨 처음 혹은 맨 마지막)만 찾고 바로 다음 그룹으로 넘어 가는 경우)

- 인덱스 스킵 스캔
루스 인덱스 스캔과 비슷하지만, 루스 인덱스 스캔은 그루핑에 사용되고 인덱스 스킵 스캔은 조건절에서 사용된다.
복합 키 (컬럼1, 컬럼2) 가 있을때, 조건절에서 컬럼2만 사용 되었다면 옵티마이저는 컬럼1의 유니크 값을 조회하여 컬럼1의 조건절을 추가 한 것처럼 실행 한다.
단점 : 선행 칼럼의 유니크한 값의 갯수가 적어야 함
       쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링 인덱스)

5. 다중 칼럼 인덱스 : 인덱스는 여러개의 컬럼을 묶어서 생성 가능하다.

6. B-TREE 인덱스의 정렬 및 스캔 방향
인덱스는 각 컬럼마다 오름차순, 내림차순으로 생성 가능 하고, 생성한것과 반대 되는 방향으로도 인덱스를 읽을 수는 있다.
하지만 역순 정렬 쿼리는 정순 정렬 쿼리보다 30% 더 시간이 걸린다.
