# 인덱스
## 디스크 읽기 방식
데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건일 때가 상당히 많다.
### 랜덤 I/O와 순차 I/O
쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 바꿔서 실행할 방법은 그다지 많지 않다.  
일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이다.  
여기서 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미한다.  

### 참고 
인덱스 레인지 스캔은 랜덤 I/O를, 풀 테이블 스캔은 순차 I/O를 사용한다.  
때문에, 큰 테이블의 데이터를 대부분 읽는 작업에서는 순차 I/O를 사용하기 위해 인덱스를 사용하지 않는 경우도 있다.  

## 인덱스란?
**데이터 저장 방식별로 구분** : 대표적으로 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있다.  
- B-Tree : 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘  
- Hash : 값을 변형해서 인덱싱하므로 값의 일부만 검색하거나 범위를 검색할 때는 사용할 수 없다.

**데이터의 중복 허용 여부로 분류** :유니크 인덱스와 유니크하지 않은 인덱스로 구분할 수 있다.  
**기능별로 분류** : 전문 검색용 인덱스나 공간 검색용 인덱스 등을 예로 들 수 있다.
## B-Tree 인덱스
컬럼의 원래 값을 번형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.
### 구조 및 특성
InnoDB 스토리지 엔진을 사용하는 테이블에서는 프라이머리 키가 ROWID의 역할을 한다.
> ROWID? 물리적인 주소값

InnoDB 테이블은 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 볼 수 있다.  
InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때는 데이터 파일을 바로 찾아가지 못하고, 인덱스에 저장돼 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.
### B-Tree 인덱스 키 추가 및 삭제
#### 인덱스 키 추가
테이블의 레코드를 저장하거나 변경하는 경우 인덱스 키 추가나 삭제 작업이 발생한다.  
B-Tree는 상대적으로 쓰기 작업(새로운 키를 추가하는 작업)에 비용이 많이 드는 것으로 알려졌다.  
레코드를 추가하는 작업 비용을 1이라고 가정하면 해당 테이블의 인덱스에 키를 추가하는 작업 비용을 1.5로 예측한다.  
인덱스가 3개가 있다면 1.5 * 3 + 1 = 5.5의 비용이 발생한다.  
#### 인덱스 키 삭제
삭제 마크만 하면 작업이 완료된다.  
마킹된 공간은 방치하거나 재활용할 수 있다.  
마킹 작업 역시 디스크 I/O가 필요한 작업이고 버퍼링을 사용하여 지연처리할 수 있다.  
#### 인덱스 키 변경 
B-Tree의 키 값 변경 작업은 키 값을 삭제한 후 다시 새로운 키 값을 추가하는 형태로 처리된다.  
#### 인덱스 키 검색
인덱스 관리에 따르는 추가 비용을 감당하면서 인덱스를 구축하는 이유는 빠른 검색을 위해서다.  
B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다.    
인덱스의 키 값에 변형이 가해진 후 비교되는 경우에는 절대 B-Tree의 빠른 검색 기능을 사용할 수 없다.  

InnoDB 스토리지 엔진에서 인덱스는 더 특별한 의미가 있다.  
잠금이나 넥스트 키락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼 있다.  
따라서 UPDATE나 DELETE 문장이 실행될 때, 적절한 인덱스가 없으면 불필요하게 많은 레코드를 잠그거나 심지어 모든 레코드를 잠글 수도 있다.  
그만큼 인덱스의 설계가 중요하고 많은 부분에 영향을 미친다.  
### B-Tree 인덱스 사용에 영향을 미치는 요소
컬럼의 크기, 레코드의 건수, 유니크한 인덱스 키 값의 개수 등에 의해 성능이 영향을 받는다.  
#### 인덱스 키 값의 크기
B-Tree는 자식 노드의 개수가 가변적인 구조다.  
MySQL의 B-Tree의 자식 노드의 수는 인덱스의 페이지 크기와 키 값의 크기에 따라 결정된다.  
인덱스를 구성하는 키 값의 크기가 커지면 하나의 인덱스 페이지에 저장할 수 있는 키의 숫자가 줄어든다.  
이는 동일한 레코드를 읽더라도 디스크로부터 읽어야 하는 횟수가 늘어나고 그만큼 느려진다는 것을 의미한다.  
또한 키 값의 길이가 길어진다는 것은 인덱스의 크기가 커진다는 것을 의미하고 버퍼풀에 캐시해 둘 수 있는 레코드의 수는 줄어든다.  
#### 선택도
유니크한 값의 개수가 중요하다.  
전체 데이터가 10000개 이고 특정 컬럼에 유니크한 값의 개수가 각각 10개 1000개일 때,  
컬럼을 조회할 때 모든 조건을 만족하는 레코드가 단 1건만 있다면 각각 쓸모없는 레코드를 999개, 9개를 추가로 읽게 된다.  
유니크한 값의 개수는 인덱스나 쿼리의 효율성에 큰 영향을 미친다.  
#### 읽어야 하는 레코드의 건수
인덱스를 통해 레코드를 읽는 것은 바로 레코드를 읽는 것보다 높은 비용이 드는 작업이다.  
인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블의 20~25%를 넘어서면, 인덱스를 사용하지 않고 테이블을 모두 직접 읽어서 필터링하는 것이 효율적이다.  
### B-Tree 인덱스를 통한 데이터 읽기
#### 인덱스 레인지 스캔
인덱스의 범위가 결정됐을 때, 사용하는 방식.  
시작지점을 찾으면 그때부터는 리프 노드의 레코드만 순서대로 읽으면 된다.  
스캔하다가 리프 노드의 끝까지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아서 다시 스캔한다.  

실제 데이터 파일의 레코드를 읽어 와야 하는 경우도 많은데,  
인덱스를 통해 읽어야 할 데이터 레코드가 20~25%를 넘으면 인덱스를 통한 읽기보다 테이블의 데이터를 직접 읽는 것이 더 효율적인 처리 방식이 된다.  
#### 인덱스 풀 스캔
쿼리의 조건절에 사용된 컬럼이 인덱스의 첫번째 컬럼이 아닌 경우 발생한다.  
일반적으로 인덱스의 크기는 테이블의 크기보다 작으므로 직접 테이블을 처음부터 끝까지 읽는 것보다는 인덱스만 읽는 것이 효과적이다.  
쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는 경우 주로 이 방식이 사용된다.  
인덱스뿐만 아니라 데이터 레코드까지 모두 읽어야 한다면 절대 이 방식으로는 처리되지 않는다.  
#### 루스 인덱스 스캔
인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않는 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리한다.  
일반적으로 GROUP BY 또는 집합 함수 가운데 MAX(), MIN() 함수에 대해 최적화를 하는 경우에 사용된다.  
#### 인덱스 스킵 스캔
다중 컬럼에서 뒤의 컬럼만으로도 인덱스 검색이 가능하게 해주는 기능이다.
아래와 같은 단점이 있다.
- where 조건절에 없는 인덱스의 선행 컬럼의 유니크한 개수가 적어야 한다.
- 쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야 한다.(커버링 인덱스)

인덱스 스킵 스캔은 선행 컬럼이 가진 유니크한 값의 개수가 소량일 때만 적용 가능한 최적화이다.
### 다중 컬럼 인덱스
인덱스의 두번째 컬럼은 첫번째 컬럼에 의존해서 정렬돼 있다.  
즉 두번째 컬럼의 정렬은 첫번째 컬럼이 똑같은 레코드에서만 의미가 있다.   
다중 컬럼 인덱스에서는 인덱스 내 각 컬럼의 위치가 상당히 중요하다.  
### B-Tree 인덱스의 정렬 및 스캔 방향 
인덱스가 오름차순으로 생성됐다고 해서 그 인덱스를 오름차순으로만 읽을 수 있다는 뜻은 아니다.  
인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어 내는 실행계획에 따라 결정된다.  
#### 인덱스의 정렬
인덱스를 생성하는 시점에서 인덱스를 구성하는 각 컬럼의 정렬을 오름차순 또는 내림차순으로 설정할 수 있다.  
정렬을 혼합한 인덱스로 생성할 수 있다.  

##### 내림차순 인덱스
하나의 인덱스를 읽더라도 역순 정렬 쿼리가 정순 정렬 쿼리보다 느리다.  
그 이유는 아래와 같다.
- 페이지 잠금이 인덱스 정순 스캔에 적합한 구조이다.
- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조

많은 쿼리가 인덱스의 앞쪽 또는 뒤쪽만 집중적으로 읽어서 인덱스의 특정 페이지 잠금이 병목이 될 것으로 예상된다면,  
쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 병목현상을 완화하는 데 도움이 될 것이다.  

### B-Tree 인덱스의 가용성과 효율성
#### 비교 조건의 종류와 효율성
다중 컬럼 인덱스에서 각 컬럼의 순서와 그 컬럼에 사용된 조건이 동등 비교(=)인지 아니면 크다 또는 작다 같은 범위 조건인지에 따라 각 인덱스 컬럼의 활용 형태가 달라지며, 그 효율 또한 달라진다.

인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사 선택하는 작업을 필터링이라고 한다.  
작업의 범위를 결정하는 조건을 **작업 범위 결정 조건**이라하고,  
비교 작업 범위를 줄이지 못하고 단순히 거름종이 역할만 하는 조건을 **필터링 조건** 또는 **체크 조건**이라 한다.  
작업 범위를 결정하는 조건은 많을수록 성능을 높이지만, 체크 조건은 쿼리 성능을 높이지 못한다. 오히려 느리게 만들때가 많다.  
#### 인덱스의 가용성
B-Tree 인덱스의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬돼 있다는 것이다.  
여기서 왼쪽이란 하나의 컬럼 내에서뿐만 아니라 다중 컬럼 인덱스의 컬럼에 대해서도 함께 적용된다.  
#### 가용성과 효율성 판단
B-Tree 인덱스의 특성상 다음 조건에서는 **작업 범위 결정 조건**으로 사용할 수 없다.  
- NOT-EQUAL로 비교된 경우("<>", "NOT IN", "NOT BETWEEN", "IS NOT NULL")
- LIKE '%??'(앞부분이 아닌 뒷부분 일치) 형태로 문자열 패턴이 비교된 경우
- 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변형된 후 비교된 경우
- NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
- 데이터 타입이 서로 다른 비교(인덱스 컬럼의 타입을 변환해야 비교가 가능한 경우)
- 문자열 데이터 타입의 콜레이션이 다른 경우

> 다중 컬럼 인덱스에서 작업 범위 결정 조건으로 인덱스를 사용하는 경우  
> column_1 ~ column(i-1) 컬럼까지 동등비교  
> column_i 컬럼에 대해 다음 연산자 중 하나로 비교  
> - 동등비교
> - 크다 작다 형태
> - LIKE로 좌측 일치 패턴

## 전문 검색 인덱스
기법에 따라 단어의 어근 분석과 n-gram 분석 알고리즘으로 구분할 수 있다.  
### 어근 분석 알고리즘
다음과 같은 두 가지 중요한 과정을 거쳐서 색인 작업이 수행된다.  
- 불용어 처리  
- 어근 분석  

### n-gram 알고리즘
단순히 키워드를 검색해내기 위한 알고리즘.  
공백과 마침표를 기준으로 단어를 구분하고, 각 단어는 2글자씩 중첩해서 토큰으로 분리된다.  
이렇게 생성된 토큰들에 대해 불용어를 걸러내는 작업을 수행하는데, 이때 불용어와 동일하거나 불용어를 포함하는 경우 걸러서 버린다.  
MySQL 서버는 이렇게 구분된 토큰을 단순한 B-Tree 인덱스에 저장한다. 

### 전문 검색 인덱스의 가용성
전문 검색 인덱스를 사용하려면 반드시 다음 두 가지 조건을 갖춰야 한다.  
- 쿼리 문장이 전문 검색을 위한 문법(MATCH ... AGAINST ...)을 사용
- 테이블이 전문 검색 대상 컬럼에 대해서 전문 인덱스 보유

## 멀티 밸류 인덱스
하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스다.  
일반적인 RDBMS를 기준으로 생각하면 정규화에 위배되는 형태지만,  
JSON 데이터 타입을 지원하기 시작하면서 JSON 배열 타입의 필드에 저장된 원소들에 대한 인덱스 요건이 발생한 것이다.  
반드시 다음 함수들을 이용해서 검색해야 한다.  
- MEMBER OF()
- JSON_CONTAINS()
- JSON_OVERLAPS()

## 클러스터링 인덱스
InnoDB 스토리지 엔진에서만 지원한다.  
프라이머리 키를 기준으로 묶어서 저장하는 형태로 구현된다.  
### 클러스터링 인덱스
클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색이 매우 빠르며, 대신 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느리다.  
클러스터링 인덱스의 리프 노드에는 레코드의 모든 컬럼이 같이 저장돼 있다.  
즉, 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리되는 것이다.  

프라이머리 키가 없는 테이블의 경우 InnoDB 스토리지 엔진이 다음 우선순위 대로 프라이머리 키를 대체할 컬럼을 선택한다.  
1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
2. NOT NULL 옵션의 유니크 인덱스 중에서 첫번째 인덱스를 클러스터링 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후 클러스터링 키로 선택

적절한 클러스터링 키 후보를 찾지 못하는 경우 InnoDB 스토리지 엔진이 내부적으로 레코드의 일련번호 컬럼을 생성한다.  
이 PK는 사용자에게 노출되지 않으며 명시적으로 사용할 수 없다.  
즉, 성능 측면에서 아무 혜택이 없다.

### 세컨더리 인덱스에 미치는 영향
#### 클러스터링 X
MyISAM이나 MEMORY 테이블 같은 클러스터링되지 않은 테이블들은 INSERT 될 때 처음 저장된 공간에서 절대 이동하지 않는다.  
PK나 세컨더리 인덱스의 각 키는 그 주소(ROWID)를 이용해 실제 데이터 레코드를 찾아온다.  
#### 클러스터링 O
InnoDB에서 세컨더리 인덱스가 실제 레코드의 주소를 가지고 있다면?  
클러스터링 키 값이 변경될 때마다 데이터 레코드의 주소가 변경되고,  
그때마다 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경할 것이다.  
이러한 오버에드를 제거하기 위해 InnoDB 테이블의 모든 세컨더리 인덱스는 레코드가 저장된 주소가 아니라 PK 값을 저장하도록 구현돼 있다.  
### 클러스터링 인덱스의 장점과 단점
장점은 빠른 읽기이며 단점은 느린 쓰기이다.  
웹 서비스와 같은 온라인 트랜잭션 환경에서는 쓰기와 읽기의 비율이 1:9, 2:8 정도이기 때문에 조금 느린 쓰기를 감수하고 읽기를 빠르게 유지한다.  
### 클러스터링 테이블 사용 시 주의사항
1. 클러스터링 인덱스 키의 크기(PK가 커지면 세컨더리 인덱스의 크기도 커진다! PK는 신중하게 선택하자!)
2. PK는 AUTO_INCREMENT 보다는 업무적인 컬럼으로 생성(가능한 경우)
3. PK는 반드시 명시할 것
4. AUTO_INCREMENT 컬럼을 인조 식별자로 사용할 경우
   여러 개의 컬럼이 복합으로 PK를 생성하는 경우 PK의 크기가 길어질 때가 있다.
   PK의 크기가 길어도 세컨더리 인덱스가 필요하지 않다면 그대로 PK를 사용하는 것이 좋다.
   세컨더리 인덱스도 필요하고 PK의 크기도 길다면 AUTO_INCREMENT 컬럼을 추가하고 PK로 설정하면 된다.
   이렇게 PK를 대체하기 위해 인위적으로 추가된 PK를 인조 식별자라고 한다.
   로그 테이블과 같이 조회보다는 INSERT 위주의 테이블들은 AUTO_INCREMENT를 이요한 인조식별자를 PK로 설정하는 것이 성능향상에 도움이 된다.

## 유니크 인덱스
MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없다.  
### 유니크 인덱스와 일반 세컨더리 인덱스의 비교
구조상 아무런 차이점이 없다.  
#### 인덱스 읽기 
유니크 인덱스가 빠르다고 생각하지만 사실이 아니다.  
유니크하지 않은 세컨더리 인덱스에서 한 번 더 해야 하는 작업은 디스크 읽기가 아니라 CPU에서 컬럼 값을 비교하는 작업이기 때문에 이는 성능상 영향이 거의 없다.  
읽어야 할 레코드 건수가 같다면 성능상의 차이는 미미하다.  
#### 인덱스 쓰기
유니크 인덱스의 키 값을 쓸 때는 중복된 값이 있는지 없는지 체크해야 하므로 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느리다.  
유니크 인덱스에서 중복된 값을 체크할 때는 읽기 잠금을 사용하고, 쓰기를 할 때는 쓰기 잠금을 사용하는데 이 과정에서 데드락이 아주 빈번히 발생한다.  
유니크 인덱스는 반드시 중복 체크 해야 하므로 작업 자체를 버퍼링 하지 못해 변경 작업이 더 느리다.  
결론적으로 유일성이 꼭 보장돼야 하는 컬럼에만 유니크 인덱스를 생성해야 한다.  

## 외래키
외래키 제약이 설정되면 자동으로 연관되는 테이블의 컬럼에 인덱스까지 생성된다.  
외래키 관리에는 중요한 두 가지 특징이 있다.
- 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다.
- 외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다.
