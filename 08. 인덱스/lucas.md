# 인덱스
## 디스크 읽기 방식
데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건일 때가 상당히 많다.
### 랜덤 I/O와 순차 I/O
쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 바꿔서 실행할 방법은 그다지 많지 않다.  
일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이다.  
여기서 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미한다.  
## 인덱스란?
**데이터 저장 방식별로 구분할 경우** 대표적으로 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있다.  
- B-Tree : 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘  
- 값을 변형해서 인덱싱하므로 값의 일부만 검색하거나 범위를 검색할 때는 사용할 수 없다.  
**데이터의 중복 허용 여부**로 분류햐면 유니크 인덱스와 유니크하지 않은 인덱스로 구분할 수 있다.  
**기능별로** 분류하면 전문 검색용 인덱스나 공간 검색용 인덱스 등을 예로 들 수 있다.
## B-Tree 인덱스
컬럼의 원래 값을 번형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.
### 구조 및 특성
InnoDB 스토리지 엔진을 사용하는 테이블에서는 프라이머리 키가 ROWID의 역할을 한다.
> ROWID? 물리적인 주소값

InnoDB 테이블은 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 볼 수 있다.  
InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때는 데이터 파일을 바로 찾아가지 못하고, 인덱스에 저장돼 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.
### B-Tree 인덱스 키 추가 및 삭제
#### 인덱스 키 추가
테이블의 레코드를 저장하거나 변경하는 경우 인덱스 키 추가나 삭제 작업이 발생한다.  
B-Tree는 상대적으로 쓰기 작업(새로운 키를 추가하는 작업)에 비용이 많이 드는 것으로 알려졌다.  
레코드를 추가하는 작업 비용을 1이라고 가정하면 해당 테이블의 인덱스에 키를 추가하는 작업 비용을 1.5로 예측한다.  
인덱스가 3개가 있다면 1.5 * 3 + 1 = 5.5의 비용이 발생한다.  
#### 인덱스 키 삭제
삭제 마크만 하면 작업이 완료된다.  
마킹된 공간은 방치하거나 재활용할 수 있다.  
마킹 작업 역시 디스크 I/O가 필요한 작업이고 버퍼링을 사용하여 지연처리할 수 있다.  
#### 인덱스 키 변경 
B-Tree의 키 값 변경 작업은 키 값을 삭제한 후 다시 새로운 키 값을 추가하는 형태로 처리된다.  
#### 인덱스 키 검색
인덱스 관리에 따르는 추가 비용을 감당하면서 인덱스를 구축하는 이유는 빠른 검색을 위해서다.  
B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다.    
인덱스의 키 값에 변형이 가해진 후 비교되는 경우에는 절대 B-Tree의 빠른 검색 기능을 사용할 수 없다.  

InnoDB 스토리지 엔진에서 인덱스는 더 특별한 의미가 있다.  
잠금이나 넥스트 키락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼 있다.  
따라서 UPDATE나 DELETE 문장이 실행될 때, 적절한 인덱스가 없으면 불필요하게 많은 레코드를 잠그거나 심지어 모든 레코드를 잠글 수도 있다.  
그만큼 인덱스의 설계가 중요하고 많은 부분에 영향을 미친다.  
