4. 아키텍처

4.1 엔진 아키텍처

4.1.1 MySQL의 전체 구조

커넥션 핸들러							-
  	ㅣ								ㅣ - my sql 엔진
인터페이스, 파서, 옵티마이저, 캐시 & 버퍼		-
	ㅣ
스토리지 엔진(innodb, myisam, memory)

mysql 엔진 : 쿼리 요청 처리, 쿼리 실행 최적화
스토리지 엔진 : 데이터를 i/o 담당

핸들러 : 스토리지 엔진에 쓰기 또는 읽기등의 요 청을 핸들러 요청


4.1.2 스레드
mysql 서버는 스레드 기반, 포그라운드 스레드와 백 그라운드 스레드로 구분

포그라운드 스레드 : 서버에 접속된 사용자의 수 만큼 생성, 사용자의 요청 처리
사용자가 접속을 종료하면 스레드 캐시로 이동, 스레드 캐시는 스레드를 일정 갯수로 관리
버퍼나 캐시로부터 데이터 가져옴, 없으면 스토리지에서 직접 가져온다.
innodb에서는 읽기만, myISAM은 쓰기까지 포그라운드가 한다.

백그라운드 스레드
1. 인서트 버퍼를 병합
2. 로그 기록
3. innoDB에선 버퍼 풀의  데이터를 스토리지에 기록
4. 데이터를 버퍼로 읽어옴
5. 잠금이나 데드락을 모니터링
즉, 로그나 데이터를 기록하는 쓰레드.

innodb와 myisam 의 차이 : inno db에서는 쓰기 작업을 백그라운드에서 처리하여 버퍼링 가능
					myisam 에서는 클라이언트 스레드에서 쓰기도 처리 하기 때문에, 버퍼링 기능 사용 불가 (데이터가 완전히 저장 된 후 읽기 가능)


4.1.3 메모리
글로벌 메모리 영역 : mysql 서버가 시작되면서 운영체제로부터 할당. 모든 스레드가 공유
테이블 캐시
innoDB 버퍼 풀
innoDB 어댑티브 해시 인덱스
innoDB 리두 로그 버퍼

로컬(세션) 메모리 영역 : 클라이언트 스레드가 사용하는 메모리 공간.
스레드별로 독립적으로 할당, 공유되지 않음.
정렬이나 조인 할때 가끔 메모리 초과가 발생할 수 있다.
정렬 버퍼(쿼리 실행시 할당, 종료시 해제)
조인 버퍼(쿼리 실행시 할당, 종료시 해제)
바이너리 로그 캐시(커넥션 연결동안 계속 할당)
네트워크 버퍼(커넥션 연결동안 계속 할당)


4.1.4 플러그인 스토리지 엔진 모델

MySQL의 특징 중 하나, 스토리지 엔진 뿐만 아니라 다양한 플러그인이 존재.
MySQL에서 스토리지 엔진 모델은 다양한데, 그 역할은 데이터를 쓰고 읽는데 있다. 나머지는 MySQL엔진에서 대부분 처리 된다. 이때, 스토리지 엔진과 MySQL엔진 사이에서 사용하는 명령어(약속)이 핸들러이다.
하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데, 각 하위 작업이 MySQL 엔진 ㅇ에서 처리 되는지, 스토리지 엔진에서 처리 되는지가 중요하다.

MySQL 엔진 목록에서 서포트 항복의 의미
yes : 사용가능
default : yes와 같이 사용 가능 하지만, MySQL 실행에 필수 엔진을 의미
no : 현재 MySQL서버에 포함되지 않음
disabled : 서버에 있지만 활성화 되지 않음

no인 엔진을 서버에 추가 할려면 서버를 다시 컴파일 해야 한다.

4.1.5 컴포넌트
플러그인을 대체하기 위한 아키텍처
플러그인의 단점
1. MySQL 서버와만 통신 가능, 플러그인들끼리는 통신 불가능
2. MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음
3. 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움

--질문 , 그렇다면 컴포넌트는 저 단점들을 모두 보완한것인가?

4.1.6 쿼리 실행 순서
1. 쿼리 파서 - 요청된 쿼리문을 토큰으로 분리해 트리 형태의 구조로 만든다. 기본 문법 오류는 이 과정에서 발견됨

2. 전처리기 - 파서 트리를 기반으로 구조적 문제점을 확인. 각 객체의 존재 여부와 ㄱ접근 권한등을 확인

3. 옵티마이저 - 사용자의 요청을 저렴한 비용으로 가장 빠르게 처리하는 방법을 결정

4. 실행 엔진 - 실행 엔진은 핸들러에게 요청을 전달하는 역할(컨트롤러)

5. 핸들러 - 엔진에 쓰기, 읽기 등의 작업을 지시 하는 역할(서비스)

4.1.7 복제
중요하니 다음에 자세히

4.1.8 쿼리 캐시
현재 삭제됨

4.1.9 스레드 풀
커뮤니티에서는 지원하지 않음. 

4.1.10 트랜잭션 지원 메타데이터
테이블의 구조 정보나 스토어드 프로그램등의 정보를 메타 데이터라고 한다.
데이터의 일관성을 위해 현재는 innoDB에 저장중이다.
메타 데이터를 트랜잭션 기반의 테이블에서 관리 하기 때문에 데이터가 깨지지 않게 되었다.





4.2 InnoDB 스토리지 엔진 아키텍처

4.2.1 프라이머리 키에 의한 클러스터링
- 프라이머리 키 값의 순서대로 디스크에 저장됨
MyISAM에서는 클러스터링이 없기 때문에 pk와 세컨더리 인덱스의 차이가 없다.

4.2.2 외래 키 지원
외래키는 InnoDB 에서 지원하는 기능이다.
보통 불편해서 실제로는 사용하지 않지만, 지원을 하고 안하고는 큰 차이다.
설정을 잠시 비활성 해놓으면 한쪽 테이블만 수정 가능, 그러나 다시 활성화 할때에는 데이터의 일관성을 맞춰 주어야 한다.

4.2.3 MVCC(Multi Version Concureency Control)
잠금을 사용하지 않는 일관된 읽기를 제공하는 기능.
하나의 레코드에 대해 여러개의 버전이 동시에 관리된다.
격리 수준이 uncommitted 이면 쿼리 실행 되었더라도 커밋 이전 데이터를,
		committed 이면 커밋 전이라도 커밋 된 것처럼 데이터를 조회 한다.


4.2.4 잠금 없는 일관된 읽기
MVCC에 의해 트랜잭션이 진행중이더라도 다른 사용자가 읽기 가능하다.

4.2.5 자동 데드락 감지
데드락 - 트랜잭션이 다른 트랜잭션때문에 대기중, 근데 그 트랜잭션도 대기중인 트랜잭션 때문에 대기중이라 무한 대기하게 되는 상황

데드락을 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리.
InnoDB는 MySQL엔진에서 관리되는 잠금을 확인하지 못해서 데드락 감지가 불안정 할 수 있는데, innodb_table_locks를 활성화 하면 상위 엔진의 잠금도 확인 가능해지기 때문에 어지간하면 활성화 해두는게 좋다.

서비스가 많아지면 이 기능때문에 성능상 문제가 생길수도 있어 끄는 방법도 있다. 이때는 innodb_lock_wait_timeout은 잠금이 일정 시간 이상 지나면 실패 처리 할 수 있도록 해주는 기능이니 이걸 활성화 하자.

4.2.6 자동화된 장애 복구
InnoDB 엔진은 자동 복구를 하지만 하드웨어 이슈등 소프트웨어로 대처하기 힘든 상황에 대해 설명해두었다. 요약 해도 길어지니 책을 참조(1권 105 페이지)

4.2.7 버퍼 풀
디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다.
쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 버퍼 역할도 같이 한다.

4.2.7.1 버퍼 풀의 크기 설정
버퍼 풀의 크기를 적당히 적은 값으로 설정 후 조금씩 증가 시키는것이 최적이다.
단, 크기 변경은 크리티컬한 작업이기 때문에 작업은 한가한 시점에 하자.
InnoDB에서는 버퍼 풀을 하나로 관리하지 않고 여러 개로 쪼개어 관리 한다.
이때 쪼개진 버퍼 풀을 버퍼 풀 인스턴스라고 표현한다.
기본값은 8개이지만, 버퍼풀 메모리가 1GB미만이면 1개의 인스턴스만 생성된다.

4.2.7.2 버퍼 풀의 구조
버퍼 풀이라는 메모리 공간을 페이지 크기로 조각내어 각 조각에 저장한다.
페이지 크기 조각을 관리하기 위해 LRU리스트와 플러시 리스트, 프리 리스트라는 3개의 자료구조로 관리한다.

프리 리스트 - 실제 사용자 데이터로 채워지지 않은 비어있는 목록
LRU 리스트 - LRU와 MRU 리스트가 결합된 형태

형태
	LRU 	머리
		꼬리
	MRU	머리
		꼬리

LRU리스트를 관리하는 목적은, 한번 읽어온 데이터를 최대한 오랫동안 버퍼풀 메모리에 유지해서 읽기를 최소화 하기 위함.

InnoDB 스토리지 엔진에서 데이터를 찾는 과정을 요약하면 다음과 같다.
1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
2. 디스크에서 필요한 페이지를 버퍼 풀에 적재하고, 적제된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
3. LRU 헤더에 적재된 데이터가 실제로 읽히면 MRU 헤더 부분으로 이동
4. 버퍼 풀에 상주하는 데이터는 최근 접속순으로 나이를 먹고, 나이가 많아지면 버퍼 풀에서 제거, 이후 데이터가 다시 사용되면 나이가 초기화 된 후 MRU의 헤더 부분으로 이동
5. 만약 해당 페이지가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가

플러시 리스트 - 디스크로 동기화 되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 변경 시점 기준의 페이지 목록을 관리한다. 즉, 디스크에서 읽은 데이터가 변경 된다면 플러시 리스트에서 관리된다.


4.2.7.3 버퍼 풀과 리두 로그
버퍼 풀의 메모리를 늘리면 캐시 기능만 향상된다. 버퍼 풀의 버퍼링 기능까지 향상시키려면 버퍼 풀과 리두 로그와의 관계를 먼저 이해해야 한다.

더티 페이지는 리두 로그와 체크 포인트를 가지게 되는데, 이때 체크 포인트가 있는 리두 로그를 재사용 불가능한, 활성 리두 로그라고 한다.
리두 로그 파일의 공간은 계속 순환되어 재사용되지만, 매번 로그 포지션은 계속 증가 하는데, 이를 LSN이라고 한다. 
더티 페이지의 데이터를 커밋 할때, 가장 최근 체크 포인트의 LSN이 활성 리두 로그 공간의 시작점이 된다. 이때 최근 체크 포인트와 마지막 리두 로그 엔트리의 LSN의 차이를 체크 포인트 에이지라고 한다. 즉, 활성 리두 로그 공간의 크기이다.
최근 체크 포인트의 LSN보다 작은 LSN을 가진 데이터들은 모두 디스크로 동기화 되어야 한다.

버퍼 풀은 데이터를 모두 가지고 있으므로 큰게 좋고, 리두 로그는 변경점만 기록 하기 때문에 보다 작은게 좋다. 물론 너무 커지면 오히려 버퍼풀을 활용하지 못하기 때문에 적당한게 좋다.




4.2.8 Double Write Buffer

4.2.9 언두 로그
데이터 조작 후 커밋 되기 전에 상태를 저장하는 로그

4.2.10 체인지 버퍼

4.2.11 리두 로그 및 로그 버퍼

4.2.12 어뎁티브 해시 인덱스

4.2.13 InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교

4.3 MyISAM 스토리지 엔진
- 제외

4.4 MySQL 로그 파일

4.4.1 에러 로그 파일

4.4.2 제너럴 쿼리 로그 파일

4.4.3 슬로우 쿼리 로그



